//去掉最后一位 10110>>1011 x>>1
//在最后添加0 1011>>10110 x<<1
//在最后添加1 1011>>10111 (x<<1)|1
//右数第k位变成1 100011>>101011,k=4 x|(1<<(k-1))
//右数第k位变成0 101011>>100011,k=4 x&~(1<<(k-1))
//获取右数第k位 101011>>1,k=4 (x>>(k-1))&1
//截取最后k位 101011>>1011,k=4 x((1<<k)-1)
//把右边连续的1变成0 101011>>101000 x&(x+1)
//把右起第一个0变成1 101011>>101111 x|(x+1)
//把右边连续的0变成1 101000>>101111 x|(x-1)
//把右起第一个1变成0 101000>>100000 x&(x-1)
//取右边连续的1 101111>>1111 (x^(x+1))>>1


//判断符号时候相同
int x,y;
bool f=((x^y)<0);

//判断一个数是否是2的幂次
int x;
bool f=(x&(x-1))==0;


int x,y,res;
//计算较小值
res=y^((x^y)&-(x<y));
//计算较大值
res=x^((x^y)&-(x<y));


int x;
//得到右数第一个1和后面的0构成的数
int lowbit(x){return x-x&(x-1);}
int lowbit(x){return x&(-x);}

//计算一个数的二进制有几个1
int x,c=0;
for(;x;c++)x=x&(x-1);
